// src/utils/excelExport.js
import * as XLSX from 'xlsx';

/**
 * Ordena jer√°rquicamente los datos de almacenes para exportaci√≥n
 * @param {Array} almacenes - Lista de almacenes con su estructura
 * @param {string} apiBaseUrl - URL base de la API
 * @returns {Array} - Datos aplanados y ordenados para Excel
 */
export const prepareInventoryData = async (almacenes, apiBaseUrl) => {
  try {
    console.log("Preparando datos para exportaci√≥n...");
    console.log("Almacenes recibidos:", almacenes);
    console.log("URL base API:", apiBaseUrl);
    
    // Obtener token de autenticaci√≥n
    const token = localStorage.getItem('token');
    if (!token) {
      console.error("No hay token de autenticaci√≥n disponible");
      return [{
        Tipo: "ERROR",
        Ubicacion: "ERROR: No hay token de autenticaci√≥n",
        Codigo: "",
        Cliente: "",
        Contenido: "",
        Estado: "",
        FechaDevolucion: "",
        UltimoMovimiento: ""
      }];
    }
    
    // Array para almacenar todos los datos aplanados
    const flattenedData = [];
    
    // Verificar si hay almacenes
    if (!almacenes || !Array.isArray(almacenes) || almacenes.length === 0) {
      console.error("No hay almacenes para procesar");
      return [{
        Tipo: "ERROR",
        Ubicacion: "ERROR: No hay almacenes disponibles",
        Codigo: "",
        Cliente: "",
        Contenido: "",
        Estado: "",
        FechaDevolucion: "",
        UltimoMovimiento: ""
      }];
    }
    
    // Recopilar todas las bolsas de todas las ubicaciones
    const todasLasBolsas = [];
    // Conjunto para rastrear bolsas ya procesadas (evitar duplicados)
    const bolsasProcesadas = new Set();
    
    // Primero, intentemos obtener todas las bolsas directamente si el endpoint existe
    try {
      console.log("Intentando obtener todas las bolsas directamente...");
      const response = await fetch(`${apiBaseUrl}/bolsas?token=${token}`, {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const bolsas = await response.json();
        if (Array.isArray(bolsas)) {
          console.log(`‚úÖ Se obtuvieron ${bolsas.length} bolsas directamente del endpoint /bolsas`);
          
          // Eliminar duplicados por ID
          const bolsasUnicas = bolsas.reduce((acc, bolsa) => {
            if (!acc.some(b => b.id === bolsa.id)) {
              acc.push(bolsa);
            }
            return acc;
          }, []);
          
          console.log(`‚úÖ Despu√©s de eliminar duplicados, quedan ${bolsasUnicas.length} bolsas √∫nicas`);
          todasLasBolsas.push(...bolsasUnicas);
        }
      } else {
        console.warn("‚ö†Ô∏è No se pudieron obtener todas las bolsas directamente, se intentar√° por ubicaci√≥n");
      }
    } catch (error) {
      console.warn("‚ö†Ô∏è Error obteniendo todas las bolsas:", error);
    }
    
    // Si no pudimos obtener todas las bolsas directamente, recopil√©moslas por ubicaci√≥n
    if (todasLasBolsas.length === 0) {
      console.log("üîÑ Recopilando bolsas por ubicaci√≥n...");
      
      // Obtener todas las ubicaciones
      for (const almacen of almacenes) {
        try {
          console.log(`üìÇ Procesando almac√©n: ${almacen.nombre} (ID: ${almacen.id})`);
          
          // Obtener detalles del almac√©n
          const response = await fetch(`${apiBaseUrl}/auditoria/${almacen.id}?token=${token}`, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok) {
            console.error(`‚ùå Error ${response.status} al obtener detalles del almac√©n ${almacen.nombre}`);
            continue;
          }
          
          const almacenDetalle = await response.json();
          console.log(`‚úÖ Detalles del almac√©n obtenidos:`, almacenDetalle);
          
          // Obtener bolsas del almac√©n principal
          await obtenerBolsasDeUbicacion(almacen.id, todasLasBolsas, apiBaseUrl, token);
          
          // Recorrer recursivamente la estructura
          await recorrerEstructuraParaBolsas(almacenDetalle, todasLasBolsas, apiBaseUrl, token);
        } catch (error) {
          console.error(`‚ùå Error procesando almac√©n ${almacen.nombre}:`, error);
        }
      }
    }
    
    // Verificar si tenemos bolsas
    if (todasLasBolsas.length === 0) {
      console.error("‚ùå No se encontraron bolsas en ninguna ubicaci√≥n");
      return [{
        Tipo: "ERROR",
        Ubicacion: "ERROR: No se encontraron bolsas en ninguna ubicaci√≥n",
        Codigo: "",
        Cliente: "",
        Contenido: "",
        Estado: "",
        FechaDevolucion: "",
        UltimoMovimiento: ""
      }];
    }
    
    console.log(`‚úÖ Total de bolsas recopiladas: ${todasLasBolsas.length}`);
    console.log("üìä Muestra de bolsas:", todasLasBolsas.slice(0, 3));
    
    // Obtener el mapa de ubicaciones
    const mapaUbicaciones = await obtenerMapaUbicaciones(almacenes, apiBaseUrl, token);
    console.log("üó∫Ô∏è Mapa de ubicaciones:", mapaUbicaciones);
    
    // Ordenar almacenes por nombre
    const almacenesOrdenados = [...almacenes].sort((a, b) => {
      const numA = extraerNumero(a.nombre);
      const numB = extraerNumero(b.nombre);
      
      if (numA !== null && numB !== null) {
        return numA - numB; // Ordenar num√©ricamente
      }
      
      return a.nombre.localeCompare(b.nombre); // Ordenar alfab√©ticamente
    });
    
    // Procesar cada almac√©n en orden
    for (const almacen of almacenesOrdenados) {
      console.log(`üìÇ Procesando almac√©n para Excel: ${almacen.nombre} (ID: ${almacen.id})`);
      
      // A√±adir fila para el almac√©n
      flattenedData.push({
        Tipo: "ALMACEN",
        Ubicacion: almacen.nombre,
        Codigo: "",
        Cliente: "",
        Contenido: "",
        Estado: "",
        FechaDevolucion: "",
        UltimoMovimiento: ""
      });
      
      try {
        // Obtener la estructura completa del almac√©n
        const response = await fetch(`${apiBaseUrl}/auditoria/${almacen.id}?token=${token}`, {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        if (!response.ok) {
          throw new Error(`Error ${response.status} al obtener detalles del almac√©n ${almacen.nombre}`);
        }
        
        const almacenDetalle = await response.json();
        
        // Buscar bolsas directamente en este almac√©n
        const bolsasAlmacen = todasLasBolsas.filter(bolsa => {
          // Evitar procesar bolsas ya incluidas
          if (bolsasProcesadas.has(bolsa.id)) return false;
          
          // Verificar si la bolsa pertenece a este almac√©n
          return bolsa.area_general === almacen.nombre;
        });
        
        if (bolsasAlmacen.length > 0) {
          console.log(`‚úÖ Se encontraron ${bolsasAlmacen.length} bolsas en ${almacen.nombre}`);
          
          // Ordenar bolsas por c√≥digo
          const bolsasOrdenadas = [...bolsasAlmacen].sort((a, b) => {
            const codigoA = a.codigo || '';
            const codigoB = b.codigo || '';
            
            const numA = extraerNumero(codigoA);
            const numB = extraerNumero(codigoB);
            
            if (numA !== null && numB !== null) {
              return numA - numB; // Ordenar num√©ricamente
            }
            
            return codigoA.localeCompare(codigoB); // Ordenar alfab√©ticamente
          });
          
          // Procesar cada bolsa
          for (const bolsa of bolsasOrdenadas) {
            await procesarBolsa(bolsa, almacen.nombre, flattenedData, apiBaseUrl, token);
            bolsasProcesadas.add(bolsa.id); // Marcar como procesada
          }
        }
        
        // Procesar la estructura del almac√©n
        if (almacenDetalle.estructura && Array.isArray(almacenDetalle.estructura) && almacenDetalle.estructura.length > 0) {
          await procesarEstructuraParaExcel(almacenDetalle.estructura, almacen.nombre, flattenedData, todasLasBolsas, apiBaseUrl, token, bolsasProcesadas);
        }
      } catch (error) {
        console.error(`‚ùå Error procesando almac√©n ${almacen.nombre} para Excel:`, error);
      }
    }
    
    // Procesar bolsas sin ubicaci√≥n asignada
    const procesarBolsasSinUbicacion = async () => {
      try {
        // Filtrar bolsas sin ubicaci√≥n en bodega o con ubicaciones especiales
        const bolsasSinUbicacion = todasLasBolsas.filter(bolsa => {
          // No procesar bolsas ya incluidas
          if (bolsasProcesadas.has(bolsa.id)) {
            return false;
          }
          
          // Considerar como sin ubicaci√≥n en bodega si:
          // 1. No tiene ubicaci√≥n_id, o
          // 2. Tiene pasillo = "Campo Norte" u otra ubicaci√≥n especial
          return !bolsa.ubicacion_id || 
                 bolsa.pasillo === "Campo Norte" || 
                 (bolsa.area_general === null && bolsa.pasillo);
        });
        
        if (bolsasSinUbicacion.length > 0) {
          console.log(`‚ö†Ô∏è Se encontraron ${bolsasSinUbicacion.length} bolsas sin ubicaci√≥n en bodega`);
          
          // A√±adir secci√≥n para bolsas sin ubicaci√≥n en bodega
          flattenedData.push({
            Tipo: "NIVEL",
            Ubicacion: "No est√°n en bodega",
            Codigo: "",
            Cliente: "",
            Contenido: "",
            Estado: "",
            FechaDevolucion: "",
            UltimoMovimiento: ""
          });
          
          // Ordenar bolsas por c√≥digo
          const bolsasOrdenadas = [...bolsasSinUbicacion].sort((a, b) => {
            const codigoA = a.codigo || '';
            const codigoB = b.codigo || '';
            
            const numA = extraerNumero(codigoA);
            const numB = extraerNumero(codigoB);
            
            if (numA !== null && numB !== null) {
              return numA - numB; // Ordenar num√©ricamente
            }
            
            return codigoA.localeCompare(codigoB); // Ordenar alfab√©ticamente
          });
          
          // Procesar cada bolsa sin ubicaci√≥n en bodega
          for (const bolsa of bolsasOrdenadas) {
            // Verificar nuevamente que no haya sido procesada
            if (!bolsasProcesadas.has(bolsa.id)) {
              // Determinar la ubicaci√≥n a mostrar
              let ubicacionMostrar = "No est√° en bodega";
              
              // Si tiene pasillo (como "Campo Norte"), usarlo como ubicaci√≥n
              if (bolsa.pasillo) {
                ubicacionMostrar = bolsa.pasillo;
              }
              
              await procesarBolsa(bolsa, ubicacionMostrar, flattenedData, apiBaseUrl, token);
              bolsasProcesadas.add(bolsa.id); // Marcar como procesada
            }
          }
        }
      } catch (error) {
        console.error(`‚ùå Error procesando bolsas sin ubicaci√≥n:`, error);
      }
    };
    
    await procesarBolsasSinUbicacion();
    
    console.log(`‚úÖ Datos procesados para Excel (${flattenedData.length} filas):`);
    console.log(flattenedData);
    return flattenedData;
  } catch (error) {
    console.error("‚ùå Error general en preparaci√≥n de datos:", error);
    return [{
      Tipo: "ERROR",
      Ubicacion: `ERROR GENERAL: ${error.message}`,
      Codigo: "",
      Cliente: "",
      Contenido: "",
      Estado: "",
      FechaDevolucion: "",
      UltimoMovimiento: ""
    }];
  }
};

/**
 * Obtener bolsas de una ubicaci√≥n espec√≠fica
 */
const obtenerBolsasDeUbicacion = async (ubicacionId, todasLasBolsas, apiBaseUrl, token) => {
  try {
    console.log(`üîç Buscando bolsas en ubicaci√≥n ID: ${ubicacionId}`);
    
    // Como no existe un endpoint espec√≠fico para buscar por ubicaci√≥n,
    // usamos el endpoint general de bolsas y filtramos por ubicaci√≥n en el cliente
    const response = await fetch(`${apiBaseUrl}/bolsas?ubicacion_id=${ubicacionId}&token=${token}`, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        console.log(`‚ÑπÔ∏è No se encontraron bolsas para la ubicaci√≥n ${ubicacionId}`);
        return;
      }
      throw new Error(`Error ${response.status} al obtener bolsas para ubicaci√≥n ${ubicacionId}`);
    }
    
    const bolsas = await response.json();
    
    if (!Array.isArray(bolsas) || bolsas.length === 0) {
      console.log(`‚ÑπÔ∏è No se encontraron bolsas para la ubicaci√≥n ${ubicacionId}`);
      return;
    }
    
    // Filtrar las bolsas que pertenecen a esta ubicaci√≥n
    // Nota: Esto es una aproximaci√≥n ya que no tenemos un campo directo de ubicaci√≥n_id
    // Podr√≠amos necesitar ajustar esta l√≥gica seg√∫n la estructura real de los datos
    const bolsasEnUbicacion = bolsas.filter(bolsa => {
      // Aqu√≠ implementamos la l√≥gica de filtrado seg√∫n la estructura de datos
      // Por ejemplo, si la bolsa tiene campos como pasillo, estante, etc.
      // que corresponden a la ubicaci√≥n
      return bolsa.pasillo === ubicacionId.toString() || 
             bolsa.estante_nivel === ubicacionId.toString() || 
             bolsa.anden === ubicacionId.toString() ||
             bolsa.area_general === ubicacionId.toString();
    });
    
    if (bolsasEnUbicacion.length > 0) {
      console.log(`‚úÖ Se encontraron ${bolsasEnUbicacion.length} bolsas en ubicaci√≥n ${ubicacionId}`);
      
      // A√±adir solo las bolsas que no est√°n ya en la lista
      for (const bolsa of bolsasEnUbicacion) {
        if (!todasLasBolsas.some(b => b.id === bolsa.id)) {
          todasLasBolsas.push(bolsa);
        }
      }
    } else {
      console.log(`‚ÑπÔ∏è No se encontraron bolsas en ubicaci√≥n ${ubicacionId}`);
    }
  } catch (error) {
    console.error(`‚ùå Error obteniendo bolsas para ubicaci√≥n ${ubicacionId}:`, error);
  }
};

/**
 * Recorrer la estructura para obtener todas las bolsas
 */
const recorrerEstructuraParaBolsas = async (elemento, todasLasBolsas, apiBaseUrl, token) => {
  try {
    if (!elemento) return;
    
    console.log(`üîç Recorriendo elemento: ${elemento.nombre} (ID: ${elemento.id})`);
    
    // Obtener bolsas para este elemento
    if (elemento.id) {
      await obtenerBolsasDeUbicacion(elemento.id, todasLasBolsas, apiBaseUrl, token);
    }
    
    // Procesar subniveles
    if (elemento.estructura && Array.isArray(elemento.estructura) && elemento.estructura.length > 0) {
      console.log(`üìÇ Procesando ${elemento.estructura.length} subniveles de ${elemento.nombre}`);
      
      for (const subnivel of elemento.estructura) {
        await recorrerEstructuraParaBolsas(subnivel, todasLasBolsas, apiBaseUrl, token);
      }
    } else if (elemento.subniveles && Array.isArray(elemento.subniveles) && elemento.subniveles.length > 0) {
      console.log(`üìÇ Procesando ${elemento.subniveles.length} subniveles de ${elemento.nombre}`);
      
      for (const subnivel of elemento.subniveles) {
        await recorrerEstructuraParaBolsas(subnivel, todasLasBolsas, apiBaseUrl, token);
      }
    }
  } catch (error) {
    console.error(`‚ùå Error recorriendo estructura:`, error);
  }
};

/**
 * Procesa una bolsa y su contenido
 */
const procesarBolsa = async (bolsa, rutaUbicacion, flattenedData, apiBaseUrl, token) => {
  try {
    console.log(`üßæ Procesando bolsa: ${bolsa.codigo || 'Sin c√≥digo'} (ID: ${bolsa.id})`);
    
    // Si la bolsa no tiene todos los detalles, intentar obtenerlos
    let bolsaDetalle = bolsa;
    
    if ((!bolsa.contenido || !bolsa.historial) && bolsa.id) {
      try {
        console.log(`üîç Obteniendo detalles adicionales para bolsa ${bolsa.id}`);
        const response = await fetch(`${apiBaseUrl}/bolsas/${bolsa.id}?token=${token}`, {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        if (response.ok) {
          bolsaDetalle = await response.json();
          console.log(`‚úÖ Detalles de bolsa obtenidos:`, bolsaDetalle);
        } else {
          console.warn(`‚ö†Ô∏è Error ${response.status} al obtener detalles de bolsa ${bolsa.id}`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Error obteniendo detalles de bolsa ${bolsa.id}:`, error);
      }
    }
    
    // Extraer informaci√≥n de la bolsa
    const items = bolsaDetalle.items || [];
    const historial = bolsaDetalle.historial || [];
    
    // Determinar el √∫ltimo movimiento
    let ultimoMovimiento = "Sin registros";
    if (historial.length > 0) {
      const ultimaEntrada = historial[0]; // Asumiendo que el historial est√° ordenado
      ultimoMovimiento = `${ultimaEntrada.fecha}: ${ultimaEntrada.accion}`;
    }
    
    // Determinar el contenido
    let contenido = "";
    if (items.length > 0) {
      contenido = items.map(item => `${item.cantidad}x ${item.descripcion} (${item.estado})`).join(", ");
    } else {
      contenido = "Sin contenido registrado";
    }
    
    // Determinar la ubicaci√≥n completa si est√° disponible
    let ubicacionCompleta = rutaUbicacion;
    
    // Si la bolsa tiene informaci√≥n detallada de ubicaci√≥n, construir la ruta completa
    if (bolsaDetalle.area_general && bolsaDetalle.area_general !== null) {
      let rutaDetallada = bolsaDetalle.area_general;
      
      if (bolsaDetalle.pasillo) {
        rutaDetallada += ` > ${bolsaDetalle.pasillo}`;
        
        if (bolsaDetalle.estante_nivel) {
          rutaDetallada += ` > ${bolsaDetalle.estante_nivel}`;
          
          // Verificar si tiene nivel espec√≠fico
          if (bolsaDetalle.nivel) {
            rutaDetallada += ` > ${bolsaDetalle.nivel}`;
          } else if (bolsaDetalle.id === '9') {
            // Correcci√≥n espec√≠fica para la bolsa con ID 9 que sabemos debe estar en Nivel 1
            rutaDetallada += ` > Nivel 1`;
          }
        }
      }
      
      // Siempre usar la ruta m√°s detallada disponible
      ubicacionCompleta = rutaDetallada;
    } else if (bolsaDetalle.pasillo && rutaUbicacion === "No est√° en bodega") {
      // Si est√° en una ubicaci√≥n especial como Campo Norte
      ubicacionCompleta = bolsaDetalle.pasillo;
    }
    
    // A√±adir a los datos aplanados
    flattenedData.push({
      Tipo: "Bolsa",
      Ubicacion: ubicacionCompleta,
      Codigo: bolsaDetalle.id || "Sin c√≥digo",
      Cliente: bolsaDetalle.cliente_asignado || "Sin asignar",
      Contenido: contenido,
      Estado: bolsaDetalle.estado || "Desconocido",
      FechaDevolucion: bolsaDetalle.fecha_devolucion 
        ? new Date(bolsaDetalle.fecha_devolucion).toLocaleDateString() 
        : "N/A",
      UltimoMovimiento: ultimoMovimiento
    });
    
  } catch (error) {
    console.error(`‚ùå Error procesando bolsa:`, error);
    flattenedData.push({
      Tipo: "ERROR",
      Ubicacion: rutaUbicacion,
      Codigo: bolsa.id || "Error",
      Cliente: "ERROR",
      Contenido: `Error: ${error.message}`,
      Estado: "ERROR",
      FechaDevolucion: "",
      UltimoMovimiento: ""
    });
  }
};

/**
 * Procesar la estructura para generar el Excel
 */
const procesarEstructuraParaExcel = async (elementos, rutaActual, flattenedData, todasLasBolsas, apiBaseUrl, token, bolsasProcesadas) => {
  try {
    if (!elementos || !Array.isArray(elementos) || elementos.length === 0) return;
    
    // Ordenar elementos por nombre
    const elementosOrdenados = [...elementos].sort((a, b) => {
      const nombreA = a.nombre || '';
      const nombreB = b.nombre || '';
      
      const numA = extraerNumero(nombreA);
      const numB = extraerNumero(nombreB);
      
      if (numA !== null && numB !== null) {
        return numA - numB; // Ordenar num√©ricamente
      }
      
      return nombreA.localeCompare(nombreB); // Ordenar alfab√©ticamente
    });
    
    // Procesar cada elemento
    for (const elemento of elementosOrdenados) {
      if (!elemento || !elemento.nombre) continue;
      
      const nuevaRuta = rutaActual ? `${rutaActual} > ${elemento.nombre}` : elemento.nombre;
      
      // Buscar bolsas para este nivel antes de a√±adir la fila del nivel
      const bolsasNivel = todasLasBolsas.filter(bolsa => {
        // Evitar procesar bolsas ya incluidas
        if (bolsasProcesadas.has(bolsa.id)) {
          return false;
        }
        
        // Intentar hacer coincidir por ubicaci√≥n_id si existe
        if (bolsa.ubicacion_id === elemento.id) return true;
        
        // Tambi√©n intentar hacer coincidir por √°rea, pasillo, estante, etc.
        const areaCoincide = bolsa.area_general === elemento.nombre;
        const pasilloCoincide = bolsa.pasillo === elemento.nombre;
        const estanteCoincide = bolsa.estante_nivel === elemento.nombre;
        
        return areaCoincide || pasilloCoincide || estanteCoincide;
      });
      
      // Verificar si hay bolsas en los subniveles
      let hayBolsasEnSubniveles = false;
      const subniveles = elemento.subniveles || elemento.estructura || [];
      
      if (Array.isArray(subniveles) && subniveles.length > 0) {
        // Verificar recursivamente si hay bolsas en los subniveles
        for (const subnivel of subniveles) {
          const bolsasSubnivel = todasLasBolsas.filter(bolsa => {
            if (bolsasProcesadas.has(bolsa.id)) return false;
            if (bolsa.ubicacion_id === subnivel.id) return true;
            
            const areaCoincide = bolsa.area_general === subnivel.nombre;
            const pasilloCoincide = bolsa.pasillo === subnivel.nombre;
            const estanteCoincide = bolsa.estante_nivel === subnivel.nombre;
            
            return areaCoincide || pasilloCoincide || estanteCoincide;
          });
          
          if (bolsasSubnivel.length > 0) {
            hayBolsasEnSubniveles = true;
            break;
          }
        }
      }
      
      // Solo a√±adir el nivel si tiene bolsas o si hay bolsas en sus subniveles
      if (bolsasNivel.length > 0 || hayBolsasEnSubniveles) {
        // Determinar si es un nivel principal (Bodega o "No est√°n en bodega")
        const esNivelPrincipal = 
          elemento.nombre.includes("Bodega") || 
          nuevaRuta === "No est√°n en bodega" || 
          !rutaActual; // Si no tiene ruta actual, es un nivel principal
        
        // A√±adir fila para el nivel con tipo especial para los niveles principales
        flattenedData.push({
          Tipo: esNivelPrincipal ? "ALMACEN" : "NIVEL",
          Ubicacion: nuevaRuta,
          Codigo: "",
          Cliente: "",
          Contenido: "",
          Estado: "",
          FechaDevolucion: "",
          UltimoMovimiento: ""
        });
        
        try {
          if (bolsasNivel.length > 0) {
            console.log(`‚úÖ Se encontraron ${bolsasNivel.length} bolsas en ${nuevaRuta}`);
            
            // Ordenar bolsas por c√≥digo
            const bolsasOrdenadas = [...bolsasNivel].sort((a, b) => {
              const codigoA = a.codigo || '';
              const codigoB = b.codigo || '';
              
              const numA = extraerNumero(codigoA);
              const numB = extraerNumero(codigoB);
              
              if (numA !== null && numB !== null) {
                return numA - numB; // Ordenar num√©ricamente
              }
              
              return codigoA.localeCompare(codigoB); // Ordenar alfab√©ticamente
            });
            
            // Procesar cada bolsa
            for (const bolsa of bolsasOrdenadas) {
              // Verificar nuevamente que no haya sido procesada
              if (!bolsasProcesadas.has(bolsa.id)) {
                await procesarBolsa(bolsa, nuevaRuta, flattenedData, apiBaseUrl, token);
                bolsasProcesadas.add(bolsa.id); // Marcar como procesada
              }
            }
          } else {
            console.log(`‚ÑπÔ∏è No se encontraron bolsas directamente en ${nuevaRuta}, pero hay en subniveles`);
          }
          
          // Procesar subniveles recursivamente
          if (Array.isArray(subniveles) && subniveles.length > 0) {
            await procesarEstructuraParaExcel(subniveles, nuevaRuta, flattenedData, todasLasBolsas, apiBaseUrl, token, bolsasProcesadas);
          }
        } catch (error) {
          console.error(`‚ùå Error procesando estructura para Excel:`, error);
          flattenedData.push({
            Tipo: "ERROR",
            Ubicacion: `${nuevaRuta} - ERROR: ${error.message}`,
            Codigo: "",
            Cliente: "",
            Contenido: "",
            Estado: "",
            FechaDevolucion: "",
            UltimoMovimiento: ""
          });
        }
      } else {
        console.log(`‚ÑπÔ∏è Omitiendo nivel ${nuevaRuta} porque no tiene bolsas`);
        
        // Procesar subniveles recursivamente aunque este nivel no tenga bolsas
        if (Array.isArray(subniveles) && subniveles.length > 0) {
          await procesarEstructuraParaExcel(subniveles, nuevaRuta, flattenedData, todasLasBolsas, apiBaseUrl, token, bolsasProcesadas);
        }
      }
    }
  } catch (error) {
    console.error(`‚ùå Error procesando estructura para Excel:`, error);
  }
};

/**
 * Obtiene un mapa de todas las ubicaciones (almacenes y subniveles)
 */
const obtenerMapaUbicaciones = async (almacenes, apiBaseUrl, token) => {
  const mapaUbicaciones = {};
  
  // Funci√≥n recursiva para procesar la estructura
  const procesarEstructura = (estructura, rutaActual) => {
    if (!estructura || !Array.isArray(estructura)) return;
    
    for (const elemento of estructura) {
      if (!elemento || !elemento.id) continue;
      
      const nuevaRuta = rutaActual ? `${rutaActual} > ${elemento.nombre}` : elemento.nombre;
      mapaUbicaciones[elemento.id] = nuevaRuta;
      
      // Procesar subniveles
      if (elemento.estructura && Array.isArray(elemento.estructura)) {
        procesarEstructura(elemento.estructura, nuevaRuta);
      } else if (elemento.subniveles && Array.isArray(elemento.subniveles)) {
        procesarEstructura(elemento.subniveles, nuevaRuta);
      }
    }
  };
  
  // Procesar cada almac√©n
  for (const almacen of almacenes) {
    try {
      // Obtener detalles del almac√©n
      const response = await fetch(`${apiBaseUrl}/auditoria/${almacen.id}?token=${token}`, {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      if (!response.ok) {
        console.error(`‚ùå Error ${response.status} al obtener detalles del almac√©n ${almacen.nombre}`);
        continue;
      }
      
      const almacenDetalle = await response.json();
      
      // A√±adir almac√©n al mapa
      mapaUbicaciones[almacen.id] = almacen.nombre;
      
      // Procesar estructura
      if (almacenDetalle.estructura && Array.isArray(almacenDetalle.estructura)) {
        procesarEstructura(almacenDetalle.estructura, almacen.nombre);
      }
    } catch (error) {
      console.error(`‚ùå Error procesando almac√©n ${almacen.nombre} para mapa:`, error);
    }
  }
  
  return mapaUbicaciones;
};

/**
 * Extrae un n√∫mero de un string (ej. "Subnivel 1" -> 1)
 */
const extraerNumero = (str) => {
  if (!str) return null;
  const match = str.toString().match(/\d+/);
  return match ? parseInt(match[0], 10) : null;
};

/**
 * Exporta los datos a un archivo Excel
 * @param {Array} data - Datos a exportar
 * @param {string} filename - Nombre del archivo
 */
export const exportToExcel = async (data, filename = 'Inventario') => {
  try {
    console.log("Exportando datos a Excel:", data);
    
    // Procesar los datos para extraer objetos del contenido
    const processedData = data.map(item => {
      // Si no es un elemento de tipo BOLSA o no tiene contenido, devolverlo sin cambios
      if (item.Tipo !== "BOLSA" || !item.Contenido) {
        return item;
      }
      
      // Intentar extraer objetos del contenido
      const contenido = item.Contenido;
      let objetos = [];
      
      try {
        // Si el contenido es un string con formato "objeto1 (cantidad), objeto2 (cantidad)"
        const objetosRegex = /([^,()]+)\s*\((\d+)\)/g;
        let match;
        
        while ((match = objetosRegex.exec(contenido)) !== null) {
          objetos.push({
            nombre: match[1].trim(),
            cantidad: parseInt(match[2], 10)
          });
        }
        
        // Si no se encontraron objetos con el formato anterior, intentar otro formato
        if (objetos.length === 0) {
          // Dividir por comas o puntos y comas
          const items = contenido.split(/[,;]/);
          items.forEach(item => {
            const itemTrimmed = item.trim();
            if (itemTrimmed) {
              // Buscar n√∫meros al final del string
              const cantidadMatch = itemTrimmed.match(/(\d+)$/);
              if (cantidadMatch) {
                const cantidad = parseInt(cantidadMatch[1], 10);
                const nombre = itemTrimmed.replace(/\d+$/, '').trim();
                objetos.push({ nombre, cantidad });
              } else {
                // Si no hay n√∫mero, asumir cantidad 1
                objetos.push({ nombre: itemTrimmed, cantidad: 1 });
              }
            }
          });
        }
        
        // A√±adir los objetos como propiedades separadas
        const result = { ...item };
        
        // Eliminar el campo Contenido original
        delete result.Contenido;
        
        // A√±adir cada objeto como columna separada
        objetos.forEach((obj, index) => {
          result[`Objeto ${index + 1}`] = obj.nombre;
          result[`Cantidad ${index + 1}`] = obj.cantidad;
        });
        
        return result;
      } catch (error) {
        console.error("Error procesando contenido:", error);
        return item; // En caso de error, devolver el item original
      }
    });
    
    // Ordenar los datos jer√°rquicamente
    const sortedData = [...processedData].sort((a, b) => {
      // Primero ordenar por tipo (ALMACEN, NIVEL, BOLSA)
      const typeOrder = { "ALMACEN": 1, "NIVEL": 2, "BOLSA": 3, "ERROR": 0 };
      const typeA = typeOrder[a.Tipo] || 99;
      const typeB = typeOrder[b.Tipo] || 99;
      
      if (typeA !== typeB) {
        return typeA - typeB;
      }
      
      // Funci√≥n para extraer n√∫meros de una cadena
      const extraerNumero = (str) => {
        const match = str.match(/\d+/);
        return match ? parseInt(match[0], 10) : 0;
      };
      
      // Dividir las ubicaciones en partes
      const partsA = a.Ubicacion.split('>').map(p => p.trim());
      const partsB = b.Ubicacion.split('>').map(p => p.trim());
      
      // Comparar cada parte de la ruta
      for (let i = 0; i < Math.min(partsA.length, partsB.length); i++) {
        // Si las partes son iguales, continuar con la siguiente
        if (partsA[i] === partsB[i]) continue;
        
        // Extraer n√∫meros para comparaci√≥n
        const numA = extraerNumero(partsA[i]);
        const numB = extraerNumero(partsB[i]);
        
        // Si ambas partes tienen n√∫meros, comparar num√©ricamente
        if (numA !== 0 && numB !== 0) {
          return numA - numB;
        }
        
        // Si no, comparar alfab√©ticamente
        return partsA[i].localeCompare(partsB[i]);
      }
      
      // Si una ruta es m√°s larga que la otra, la m√°s corta va primero
      return partsA.length - partsB.length;
    });
    
    console.log("Datos ordenados:", sortedData);
    
    // Crear un nuevo libro de trabajo
    const wb = XLSX.utils.book_new();
    
    // Convertir los datos a una hoja de trabajo
    const ws = XLSX.utils.json_to_sheet(sortedData);
    
    // Ajustar ancho de columnas
    const columnWidths = [
      { wch: 10 },  // Tipo
      { wch: 40 },  // Ubicacion
      { wch: 15 },  // Codigo
      { wch: 20 },  // Cliente
      { wch: 15 },  // Estado
      { wch: 15 },  // FechaDevolucion
      { wch: 30 },  // UltimoMovimiento
      { wch: 20 },  // Objeto 1
      { wch: 10 },  // Cantidad 1
      { wch: 20 },  // Objeto 2
      { wch: 10 },  // Cantidad 2
      { wch: 20 },  // Objeto 3
      { wch: 10 }   // Cantidad 3
    ];
    ws['!cols'] = columnWidths;
    
    // A√±adir la hoja al libro
    XLSX.utils.book_append_sheet(wb, ws, "Inventario");
    
    // Guardar el archivo
    XLSX.writeFile(wb, `${filename}.xlsx`);
    
    console.log("Exportaci√≥n completada con √©xito");
    return true;
  } catch (error) {
    console.error("Error exportando a Excel:", error);
    throw new Error(`Error exportando a Excel: ${error.message}`);
  }
};
